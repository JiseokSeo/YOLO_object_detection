# -*- coding: utf-8 -*-
"""utils

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vMIt4Cg6dhOPNwDQ5dW8UogZY1qL0Gz1
"""

from tqdm import tqdm
import cv2
import numpy as np
import os
import glob
import zipfile
import matplotlib.pyplot as plt
import re

# 평균 해시 기반 유사도검사
def average_hash(image, hash_size=8):
    resized = cv2.resize(image, (hash_size, hash_size), interpolation=cv2.INTER_AREA)
    gray = cv2.cvtColor(resized, cv2.COLOR_BGR2GRAY)
    mean = np.mean(gray)
    return np.where(gray > mean, 1, 0)

def hamming_distance(hash1, hash2):
    return np.sum(hash1 != hash2)

# 이미지 경로들을 리스트 형태로 넣으면, 이웃한 두 이미지를 비교함
# 특정 쓰레쉬홀드 값을 넘는 리스트들이 리턴됨
def filter_similar_images(image_paths, threshold, hash_size=8):
    filtered_images = [image_paths[0]]
    for i in tqdm(range(1, len(image_paths)), desc="Filtering", unit="image"):
        imageA = cv2.imread(image_paths[i-1])
        imageB = cv2.imread(image_paths[i])

        hashA = average_hash(imageA, hash_size)
        hashB = average_hash(imageB, hash_size)
        
        hamming_dist = hamming_distance(hashA, hashB)
        
        if hamming_dist > threshold:
            filtered_images.append(image_paths[i])
    return filtered_images

def visualize_batch(image_paths, batch_size=16):
    assert batch_size <= 16, "Batch size should be less than or equal to 16."
    
    fig, axes = plt.subplots(4, 4, figsize=(16, 16), gridspec_kw={'wspace': 0, 'hspace': 0})
    
    for i, ax in enumerate(axes.flat):
        if i < len(image_paths):
            img_path = image_paths[i]
            img = cv2.imread(img_path)
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            ax.imshow(img)
            ax.axis("off")
        else:
            ax.axis("off")

    plt.show()

def only_json_name(string):
  string = string.split('/')[-1]
  return string

def compress_files(file_paths, output_path):
    with zipfile.ZipFile(output_path, 'w') as zip_file:
        for file_path in file_paths:
            zip_file.write(file_path)